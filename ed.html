<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Lighted Syntax Highlighted Textarea</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      color-scheme: dark;
      --lighted-foreground: #d4d4d4;
      --lighted-background: #0f1219;
      --lighted-caret: #ffe66d;
      --token-comment: #6a9955;
      --token-string: #ce9178;
      --token-number: #b5cea8;
      --token-keyword: #c586c0;
      --token-builtin: #4fc1ff;
      --token-punct: #dcdcdc;
      --token-tag: #4ec9b0;
      --token-attr: #9cdcfe;
      --token-attr-value: #d7ba7d;
      --token-entity: #dcdcaa;
      --token-css-ident: #9cdcfe;
      --token-css-keyword: #c586c0;
      --token-css-number: #b5cea8;
      --token-css-color: #d7ba7d;
      --token-regex: #d16969;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, rgba(52, 84, 209, 0.18), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(220, 92, 255, 0.2), transparent 40%),
        var(--lighted-background);
      color: var(--lighted-foreground);
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, "Courier New", monospace;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 36px 28px 64px;
    }

    main {
      width: min(960px, 100%);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 1.35rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    p {
      margin: 0 0 28px;
      max-width: 68ch;
      line-height: 1.6;
      color: rgba(212, 212, 212, 0.82);
    }

    .lighted {
      position: relative;
      width: 100%;
      border-radius: 12px;
      background: rgba(6, 8, 12, 0.75);
      box-shadow: 0 38px 80px rgba(0, 0, 0, 0.45);
      overflow: hidden;
    }

    .lighted-input {
      width: 100%;
      min-height: 420px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 22px 24px;
      font-size: 15px;
      line-height: 1.6;
      background: transparent;
      color: transparent;
      caret-color: var(--lighted-caret);
      resize: vertical;
      outline: none;
      position: relative;
      z-index: 1;
      white-space: pre;
      tab-size: 2;
      overflow: auto;
    }

    .lighted-input:focus {
      border-color: rgba(86, 156, 214, 0.6);
      box-shadow: 0 0 0 1px rgba(86, 156, 214, 0.4);
    }

    .lighted-input::selection {
      background: rgba(86, 156, 214, 0.32);
    }

    .lighted .overlay-host {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      border-radius: inherit;
    }
  </style>
  <script src="other/textarea-vim.js"></script>
</head>
<body>
  <main>
    <h1>Lightweight RegExp Syntax Highlighting Demo</h1>
    <p>
      The editor below keeps the original textarea for input, adds a shadow-DOM backed overlay that renders tokens,
      and incrementally retokens only the areas affected by edits.
    </p>
    <textarea id="editor" spellcheck="false">let message = 'Hello, Webfoundry!';

function greet(name) {
  /* highlight demonstration */
  let text = `${message} Welcome, ${name}!`;
  if (name === 'Camila') {
    console.log('Special handling for', name);
  }
  return text;
}

let items = [];
for (let i = 0; i < 6; i += 1) {
  items.push({ id: i, ready: i % 2 === 0 });
}

items.forEach(function (entry) {
  if (entry.ready) {
    console.log('Ready item', entry.id);
  }
});

export { greet };
</textarea>
  </main>
  
  <script type="module">
    let KEYWORDS = new Set([
      'break', 'case', 'catch', 'class', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export',
      'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'let', 'new', 'return', 'super',
      'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'await', 'static', 'of'
    ]);

    let KEYWORDS_EXPECT_EXPR = new Set([
      'return', 'throw', 'case', 'yield', 'await', 'typeof', 'delete', 'void', 'new', 'instanceof', 'in', 'of',
      'do', 'else', 'if', 'for', 'while', 'switch', 'with', 'catch', 'class', 'extends', 'import', 'export'
    ]);

    let BUILTINS = new Set([
      'Array', 'Boolean', 'Date', 'Error', 'Function', 'JSON', 'Math', 'Number', 'Object', 'Promise', 'RegExp',
      'String', 'Symbol', 'Map', 'Set', 'WeakMap', 'WeakSet', 'console', 'document', 'window', 'Intl'
    ]);

    let WHITESPACE_RE = /\s+/y;
    let NUMBER_RE = /(?:0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)/y;
    let IDENT_RE = /[A-Za-z_$][\w$]*/y;
    let PUNCT_RE = /\.\.\.|==|===|!=|!==|=>|<=|>=|\+\+|--|\+=|-=|\*=|\/=|&&|\|\||[%+\-*/&|^~<>!?:=.,;()[\]{}]/y;

    let TAG_NAME_RE = /[A-Za-z][\w:-]*/y;
    let ATTR_NAME_RE = /[A-Za-z_:][\w:.-]*/y;
    let CSS_IDENTIFIER_RE = /-?(?:[A-Za-z_]|-)[\w-]*/y;
    let CSS_NUMBER_RE = /(?:0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)/y;
    let CSS_COLOR_RE = /#[0-9a-fA-F]{3,8}/y;

    let CSS_KEYWORDS = new Set([
      'important', 'inherit', 'initial', 'unset', 'revert', 'auto', 'none', 'flex', 'grid', 'block', 'inline',
      'inline-block', 'inline-flex', 'inline-grid', 'relative', 'absolute', 'sticky', 'fixed', 'solid', 'dashed',
      'dotted', 'hidden', 'visible', 'collapse', 'uppercase', 'lowercase', 'capitalize', 'bold', 'italic', 'normal',
      'center', 'left', 'right', 'justify', 'space-between', 'space-around', 'space-evenly'
    ]);

    let HTML_ESCAPES = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };

    function normalizeText(value) {
      return value.replace(/\r?\n/g, '\n');
    }

    function matchAt(regex, text, index) {
      regex.lastIndex = index;
      let match = regex.exec(text);
      if (match && match.index === index) {
        return match[0];
      }
      return '';
    }

    function escapeHtml(text) {
      if (!text) {
        return '';
      }
      return text.replace(/[&<>"']/g, function (ch) {
        return HTML_ESCAPES[ch] || ch;
      });
    }

    function wrapToken(className, text) {
      if (!text) {
        return '';
      }
      return '<span class="' + className + '">' + escapeHtml(text) + '</span>';
    }

    function insertTextAtSelection(doc, inserted, options) {
      let textarea = doc.textarea;
      let start = textarea.selectionStart;
      let end = textarea.selectionEnd;
      let value = textarea.value;
      let before = value.slice(0, start);
      let after = value.slice(end);
      textarea.value = before + inserted + after;
      let caretStart = start + inserted.length;
      let caretEnd = caretStart;
      if (options && options.selectionStart !== undefined) {
        caretStart = start + options.selectionStart;
      }
      if (options && options.selectionEnd !== undefined) {
        caretEnd = start + options.selectionEnd;
      } else {
        caretEnd = caretStart;
      }
      textarea.selectionStart = caretStart;
      textarea.selectionEnd = caretEnd;
      return {
        start: caretStart,
        end: caretEnd
      };
    }

    function getLineIndentation(value, caretIndex, tabString) {
      let index = caretIndex != null ? caretIndex : value.length;
      let lineStart = value.lastIndexOf('\n', index - 1);
      if (lineStart === -1) {
        lineStart = 0;
      } else {
        lineStart += 1;
      }
      let cursor = lineStart;
      let indent = '';
      while (cursor < value.length) {
        let ch = value.charAt(cursor);
        if (ch === ' ') {
          indent += ' ';
          cursor += 1;
          continue;
        }
        if (ch === '\t') {
          indent += tabString;
          cursor += 1;
          continue;
        }
        break;
      }
      return indent;
    }

    function indentSelection(doc, tabString) {
      let textarea = doc.textarea;
      let start = textarea.selectionStart;
      let end = textarea.selectionEnd;
      if (start === end) {
        insertTextAtSelection(doc, tabString);
        return {
          start: textarea.selectionStart,
          end: textarea.selectionEnd
        };
      }
      let value = textarea.value;
      let lineStart = value.lastIndexOf('\n', start - 1);
      if (lineStart === -1) {
        lineStart = 0;
      } else {
        lineStart += 1;
      }
      let lastIndex = end > 0 ? end - 1 : end;
      let lineEnd = value.indexOf('\n', lastIndex);
      if (lineEnd === -1) {
        lineEnd = value.length;
      }
      let block = value.slice(lineStart, lineEnd);
      let lines = block.split('\n');
      let transformed = lines.map(function (line) {
        return tabString + line;
      }).join('\n');
      textarea.value = value.slice(0, lineStart) + transformed + value.slice(lineEnd);
      let lineCount = lines.length;
      let newStart = start + tabString.length;
      let newEnd = end + tabString.length * lineCount;
      textarea.selectionStart = newStart;
      textarea.selectionEnd = newEnd;
      return {
        start: newStart,
        end: newEnd
      };
    }

    function unindentSelection(doc, tabString) {
      let textarea = doc.textarea;
      let start = textarea.selectionStart;
      let end = textarea.selectionEnd;
      let value = textarea.value;
      let lineStart = value.lastIndexOf('\n', start - 1);
      if (lineStart === -1) {
        lineStart = 0;
      } else {
        lineStart += 1;
      }
      let lastIndex = end > 0 ? end - 1 : end;
      let lineEnd = value.indexOf('\n', lastIndex);
      if (lineEnd === -1) {
        lineEnd = value.length;
      }
      let block = value.slice(lineStart, lineEnd);
      let lines = block.split('\n');
      let originalLengths = [];
      let removedCounts = [];
      let newLines = [];
      for (let i = 0; i < lines.length; i += 1) {
        let originalLine = lines[i];
        originalLengths.push(originalLine.length);
        let removed = 0;
        let updatedLine = originalLine;
        if (updatedLine.startsWith(tabString)) {
          removed = tabString.length;
          updatedLine = updatedLine.slice(tabString.length);
        } else if (updatedLine.startsWith('\t')) {
          removed = 1;
          updatedLine = updatedLine.slice(1);
        } else {
          let spaces = 0;
          while (spaces < tabString.length && updatedLine.charAt(spaces) === ' ') {
            spaces += 1;
          }
          if (spaces > 0) {
            removed = spaces;
            updatedLine = updatedLine.slice(spaces);
          }
        }
        removedCounts.push(removed);
        newLines.push(updatedLine);
      }
      let transformed = newLines.join('\n');

      let blockLength = block.length;
      let relativeStart = start - lineStart;
      if (relativeStart < 0) {
        relativeStart = 0;
      }
      if (relativeStart > blockLength) {
        relativeStart = blockLength;
      }
      let adjustedEnd = end;
      if (adjustedEnd > lineEnd) {
        adjustedEnd = lineEnd;
      }
      let relativeEnd = adjustedEnd - lineStart;
      if (relativeEnd < 0) {
        relativeEnd = 0;
      }
      if (relativeEnd > blockLength) {
        relativeEnd = blockLength;
      }

      let computeRemovalBefore = function (relative) {
        // Walk the original lines and accumulate the indentation removed before
        // the given offset so we can adjust caret and selection anchors.
        let total = 0;
        let running = 0;
        for (let i = 0; i < lines.length; i += 1) {
          if (i > 0) {
            running += 1;
          }
          let lineLength = originalLengths[i];
          let lineStartOffset = running;
          let lineEndOffset = running + lineLength;
          let removal = removedCounts[i];
          if (relative <= lineStartOffset) {
            break;
          }
          if (relative >= lineEndOffset) {
            total += removal;
          } else {
            let offsetInLine = relative - lineStartOffset;
            total += Math.min(removal, offsetInLine);
            break;
          }
          running = lineEndOffset;
        }
        return total;
      };

      let removalBeforeStart = computeRemovalBefore(relativeStart);
      let removalBeforeEnd = computeRemovalBefore(relativeEnd);
      let totalRemoval = 0;
      for (let i = 0; i < removedCounts.length; i += 1) {
        totalRemoval += removedCounts[i];
      }
      if (end > lineEnd) {
        removalBeforeEnd = totalRemoval;
      }

      textarea.value = value.slice(0, lineStart) + transformed + value.slice(lineEnd);

      let newStart = start - removalBeforeStart;
      if (newStart < lineStart) {
        newStart = lineStart;
      }
      let newEnd = end - removalBeforeEnd;
      if (newEnd < newStart) {
        newEnd = newStart;
      }

      textarea.selectionStart = newStart;
      textarea.selectionEnd = newEnd;
      return {
        start: newStart,
        end: newEnd
      };
    }

    function detectInitialMode(value) {
      let sample = (value || '').slice(0, 400).trimStart();
      if (!sample) {
        return 'html-data';
      }
      if (sample.charAt(0) === '<') {
        return 'html-data';
      }
      return 'script';
    }

    function createState(mode, options) {
      let opts = options || {};
      return {
        mode: mode || 'html-data',
        delimiter: opts.delimiter || '',
        tagName: opts.tagName || '',
        attrQuote: opts.attrQuote || '',
        nextMode: opts.nextMode || '',
        expectExpr: opts.expectExpr !== undefined ? opts.expectExpr : true,
        lastType: opts.lastType || 'operator',
        tagClosing: !!opts.tagClosing
      };
    }

    function cloneState(state, fallbackMode) {
      if (!state) {
        return createState(fallbackMode || 'html-data');
      }
      return {
        mode: state.mode || (fallbackMode || 'html-data'),
        delimiter: state.delimiter || '',
        tagName: state.tagName || '',
        attrQuote: state.attrQuote || '',
        nextMode: state.nextMode || '',
        expectExpr: state.expectExpr !== undefined ? state.expectExpr : true,
        lastType: state.lastType || 'operator',
        tagClosing: !!state.tagClosing
      };
    }

    function sameState(a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return a.mode === b.mode && a.delimiter === b.delimiter && a.tagName === b.tagName &&
        a.attrQuote === b.attrQuote && a.nextMode === b.nextMode && a.expectExpr === b.expectExpr &&
        a.lastType === b.lastType && a.tagClosing === b.tagClosing;
    }

    function readStringLiteral(text, start, delimiter) {
      let index = start + 1;
      let length = text.length;
      let closed = false;

      while (index < length) {
        let ch = text.charAt(index);
        if (ch === '\\') {
          index += 2;
          continue;
        }
        if (ch === delimiter) {
          index += 1;
          closed = true;
          break;
        }
        index += 1;
      }

      return {
        value: text.slice(start, index),
        end: index,
        closed: closed
      };
    }

    function readRegexLiteral(text, start) {
      let index = start + 1;
      let length = text.length;
      let inClass = false;

      while (index < length) {
        let ch = text.charAt(index);
        if (ch === '\\') {
          index += 2;
          continue;
        }
        if (ch === '[') {
          inClass = true;
        } else if (ch === ']' && inClass) {
          inClass = false;
        } else if (ch === '/' && !inClass) {
          index += 1;
          while (index < length) {
            let flag = text.charAt(index);
            if (!/[a-zA-Z]/.test(flag)) {
              break;
            }
            index += 1;
          }
          return {
            value: text.slice(start, index),
            end: index,
            closed: true
          };
        } else if (ch === '\r' || ch === '\n') {
          break;
        }
        index += 1;
      }

      return {
        value: text.slice(start),
        end: length,
        closed: false
      };
    }

    function consumeEntity(text, index) {
      let length = text.length;
      let end = index + 1;
      while (end < length) {
        let ch = text.charAt(end);
        let isAlpha = (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
        let isDigit = ch >= '0' && ch <= '9';
        if (ch === ';') {
          end += 1;
          break;
        }
        if (!(isAlpha || isDigit || ch === '#' || ch === 'x' || ch === 'X')) {
          break;
        }
        end += 1;
      }
      if (end > index + 1 && end <= length && text.charAt(end - 1) === ';') {
        return {
          entity: text.slice(index, end),
          end: end
        };
      }
      return {
        entity: text.charAt(index),
        end: index + 1
      };
    }

    function startsWithIgnoreCase(text, index, match) {
      let end = index + match.length;
      if (end > text.length) {
        return false;
      }
      return text.slice(index, end).toLowerCase() === match.toLowerCase();
    }

    function markValue(state) {
      state.lastType = 'value';
      state.expectExpr = false;
    }

    function markOperator(state) {
      state.lastType = 'operator';
      state.expectExpr = true;
    }

    function markAfterKeyword(state, keyword) {
      if (KEYWORDS_EXPECT_EXPR.has(keyword)) {
        markOperator(state);
      } else {
        markValue(state);
      }
    }

    function tokenizeLine(text, prevState) {
      let state = cloneState(prevState, 'html-data');
      let htmlParts = [];
      let index = 0;
      let length = text.length;

      while (index < length) {
        if (state.mode === 'html-comment') {
          let endIndex = text.indexOf('-->', index);
          if (endIndex === -1) {
            htmlParts.push(wrapToken('token-comment', text.slice(index)));
            index = length;
            break;
          }
          htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 3)));
          index = endIndex + 3;
          state.mode = 'html-data';
          continue;
        }

        if (state.mode === 'html-attr-value') {
          let quote = state.attrQuote || state.delimiter || '"';
          let start = index;
          let closed = false;
          while (index < length) {
            let ch = text.charAt(index);
            if (ch === '\\') {
              index += 2;
              continue;
            }
            if (ch === quote) {
              let content = text.slice(start, index);
              if (content) {
                htmlParts.push(wrapToken('token-attr-value', content));
              }
              htmlParts.push(wrapToken('token-punct', quote));
              index += 1;
              closed = true;
              break;
            }
            index += 1;
          }
          if (!closed) {
            let content = text.slice(start);
            if (content) {
              htmlParts.push(wrapToken('token-attr-value', content));
            }
            index = length;
          } else {
            state.mode = 'html-tag';
            state.attrQuote = '';
            state.delimiter = '';
          }
          continue;
        }

        if (state.mode === 'html-tag') {
          if (index >= length) {
            break;
          }
          let ch = text.charAt(index);

          if (ch === '>' ) {
            htmlParts.push(wrapToken('token-punct', '>'));
            index += 1;
            if (state.tagClosing) {
              state.mode = 'html-data';
            } else if (state.nextMode) {
              let transition = state.nextMode;
              state.nextMode = '';
              state.mode = transition;
              if (transition === 'script') {
                state.expectExpr = true;
                state.lastType = 'operator';
              } else if (transition === 'style') {
                state.lastType = 'operator';
              } else {
                state.mode = 'html-data';
              }
            } else {
              state.mode = 'html-data';
            }
            state.tagName = '';
            state.tagClosing = false;
            continue;
          }

          if (ch === '/' && text.charAt(index + 1) === '>') {
            htmlParts.push(wrapToken('token-punct', '/>'));
            index += 2;
            state.mode = 'html-data';
            state.tagName = '';
            state.tagClosing = false;
            state.nextMode = '';
            continue;
          }

          let whitespace = matchAt(WHITESPACE_RE, text, index);
          if (whitespace) {
            htmlParts.push(escapeHtml(whitespace));
            index += whitespace.length;
            continue;
          }

          if (ch === '"' || ch === '\'') {
            let quote = ch;
            htmlParts.push(wrapToken('token-punct', quote));
            index += 1;
            let valueStart = index;
            while (index < length) {
              let inner = text.charAt(index);
              if (inner === '\\') {
                index += 2;
                continue;
              }
              if (inner === quote) {
                break;
              }
              index += 1;
            }
            let content = text.slice(valueStart, Math.min(index, length));
            if (content) {
              htmlParts.push(wrapToken('token-attr-value', content));
            }
            if (index < length && text.charAt(index) === quote) {
              htmlParts.push(wrapToken('token-punct', quote));
              index += 1;
            } else {
              state.mode = 'html-attr-value';
              state.attrQuote = quote;
              state.delimiter = quote;
              index = length;
            }
            continue;
          }

          if (ch === '=') {
            htmlParts.push(wrapToken('token-punct', '='));
            index += 1;
            continue;
          }

          if (ch === '&') {
            let entityInfo = consumeEntity(text, index);
            htmlParts.push(wrapToken('token-entity', entityInfo.entity));
            index = entityInfo.end;
            continue;
          }

          let attrName = matchAt(ATTR_NAME_RE, text, index);
          if (attrName) {
            htmlParts.push(wrapToken('token-attr', attrName));
            index += attrName.length;
            continue;
          }

          let start = index;
          while (index < length) {
            let c = text.charAt(index);
            if (c === '>' || (c === '/' && text.charAt(index + 1) === '>') || /\s/.test(c)) {
              break;
            }
            index += 1;
          }
          let chunk = text.slice(start, index);
          if (chunk) {
            htmlParts.push(wrapToken('token-attr-value', chunk));
          }
          continue;
        }

        if (state.mode === 'html-data') {
          if (index >= length) {
            break;
          }

          let nextLt = text.indexOf('<', index);
          let nextAmp = text.indexOf('&', index);
          let nextSpecial = length;
          if (nextLt !== -1 && nextLt < nextSpecial) {
            nextSpecial = nextLt;
          }
          if (nextAmp !== -1 && nextAmp < nextSpecial) {
            nextSpecial = nextAmp;
          }
          if (nextSpecial > index) {
            htmlParts.push(escapeHtml(text.slice(index, nextSpecial)));
            index = nextSpecial;
            continue;
          }

          if (text.startsWith('<!--', index)) {
            let endIndex = text.indexOf('-->', index + 4);
            if (endIndex === -1) {
              htmlParts.push(wrapToken('token-comment', text.slice(index)));
              state.mode = 'html-comment';
              index = length;
            } else {
              htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 3)));
              index = endIndex + 3;
            }
            continue;
          }

          if (text.startsWith('<![CDATA[', index) || text.startsWith('<?', index) || text.startsWith('<!', index)) {
            let endIndex = text.indexOf('>', index + 2);
            if (endIndex === -1) {
              htmlParts.push(wrapToken('token-comment', text.slice(index)));
              index = length;
              continue;
            }
            htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 1)));
            index = endIndex + 1;
            continue;
          }

          let ch = text.charAt(index);
          if (ch === '&') {
            let entityInfo = consumeEntity(text, index);
            htmlParts.push(wrapToken('token-entity', entityInfo.entity));
            index = entityInfo.end;
            continue;
          }

          if (ch === '<') {
            let start = index + 1;
            let closing = false;
            if (text.charAt(start) === '/') {
              closing = true;
              start += 1;
            }
            let tagName = matchAt(TAG_NAME_RE, text, start);
            if (!tagName) {
              htmlParts.push(escapeHtml('<'));
              index += 1;
              continue;
            }
            if (closing) {
              htmlParts.push(wrapToken('token-punct', '</'));
            } else {
              htmlParts.push(wrapToken('token-punct', '<'));
            }
            htmlParts.push(wrapToken('token-tag', tagName));
            index = start + tagName.length;
            state.tagName = tagName;
            state.tagClosing = closing;
            if (!closing) {
              let lower = tagName.toLowerCase();
              if (lower === 'script') {
                state.nextMode = 'script';
              } else if (lower === 'style') {
                state.nextMode = 'style';
              } else {
                state.nextMode = '';
              }
            } else {
              state.nextMode = '';
            }
            state.mode = 'html-tag';
            continue;
          }

          htmlParts.push(escapeHtml(ch));
          index += 1;
          continue;
        }

        if (state.mode === 'script-string') {
          let delimiter = state.delimiter || '"';
          let stopIndex = index;
          let closed = false;
          while (stopIndex < length) {
            let ch = text.charAt(stopIndex);
            if (ch === '\\') {
              stopIndex += 2;
              continue;
            }
            if (ch === delimiter) {
              stopIndex += 1;
              closed = true;
              break;
            }
            stopIndex += 1;
          }
          let chunk = text.slice(index, stopIndex);
          if (chunk) {
            htmlParts.push(wrapToken('token-string', chunk));
          }
          index = stopIndex;
          if (closed) {
            state.mode = 'script';
            state.delimiter = '';
            markValue(state);
          }
          continue;
        }

        if (state.mode === 'script-block-comment') {
          let endIndex = text.indexOf('*/', index);
          if (endIndex === -1) {
            htmlParts.push(wrapToken('token-comment', text.slice(index)));
            index = length;
            break;
          }
          htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
          index = endIndex + 2;
          state.mode = 'script';
          continue;
        }

        if (state.mode === 'script') {
          if (index >= length) {
            break;
          }

          let ch = text.charAt(index);
          if (ch === '<' && startsWithIgnoreCase(text, index, '</script')) {
            state.mode = 'html-data';
            state.tagName = '';
            state.tagClosing = true;
            state.nextMode = '';
            continue;
          }

          if (ch === '/' && index + 1 < length) {
            let next = text.charAt(index + 1);
            if (next === '/') {
              htmlParts.push(wrapToken('token-comment', text.slice(index)));
              index = length;
              break;
            }
            if (next === '*') {
              let endIndex = text.indexOf('*/', index + 2);
              if (endIndex === -1) {
                htmlParts.push(wrapToken('token-comment', text.slice(index)));
                state.mode = 'script-block-comment';
                index = length;
                break;
              }
              htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
              index = endIndex + 2;
              continue;
            }
            if (state.expectExpr) {
              let regexInfo = readRegexLiteral(text, index);
              htmlParts.push(wrapToken('token-regex', regexInfo.value));
              index = regexInfo.end;
              markValue(state);
              continue;
            }
          }

          if (ch === '"' || ch === '\'' || ch === '`') {
            let stringInfo = readStringLiteral(text, index, ch);
            htmlParts.push(wrapToken('token-string', stringInfo.value));
            index = stringInfo.end;
            markValue(state);
            if (!stringInfo.closed) {
              state.mode = 'script-string';
              state.delimiter = ch;
              break;
            }
            continue;
          }

          let whitespace = matchAt(WHITESPACE_RE, text, index);
          if (whitespace) {
            htmlParts.push(escapeHtml(whitespace));
            index += whitespace.length;
            continue;
          }

          let numberValue = matchAt(NUMBER_RE, text, index);
          if (numberValue) {
            htmlParts.push(wrapToken('token-number', numberValue));
            index += numberValue.length;
            markValue(state);
            continue;
          }

          let ident = matchAt(IDENT_RE, text, index);
          if (ident) {
            if (KEYWORDS.has(ident)) {
              htmlParts.push(wrapToken('token-keyword', ident));
              markAfterKeyword(state, ident);
            } else if (BUILTINS.has(ident)) {
              htmlParts.push(wrapToken('token-builtin', ident));
              markValue(state);
            } else {
              htmlParts.push(escapeHtml(ident));
              markValue(state);
            }
            index += ident.length;
            continue;
          }

          if (ch === '&') {
            let entityInfo = consumeEntity(text, index);
            htmlParts.push(wrapToken('token-entity', entityInfo.entity));
            index = entityInfo.end;
            continue;
          }

          let punct = matchAt(PUNCT_RE, text, index);
          if (punct) {
            htmlParts.push(wrapToken('token-punct', punct));
            index += punct.length;
            if (punct === ')' || punct === ']' || punct === '}') {
              markValue(state);
            } else if (punct === '.' ) {
              state.lastType = 'operator';
              state.expectExpr = false;
            } else if ((punct === '++' || punct === '--') && state.lastType === 'value') {
              markValue(state);
            } else {
              markOperator(state);
            }
            continue;
          }

          htmlParts.push(escapeHtml(ch));
          index += 1;
          continue;
        }

        if (state.mode === 'style-string') {
          let delimiter = state.delimiter || '"';
          let stopIndex = index;
          let closed = false;
          while (stopIndex < length) {
            let ch = text.charAt(stopIndex);
            if (ch === '\\') {
              stopIndex += 2;
              continue;
            }
            if (ch === delimiter) {
              stopIndex += 1;
              closed = true;
              break;
            }
            stopIndex += 1;
          }
          let chunk = text.slice(index, stopIndex);
          if (chunk) {
            htmlParts.push(wrapToken('token-string', chunk));
          }
          index = stopIndex;
          if (closed) {
            state.mode = 'style';
            state.delimiter = '';
          }
          continue;
        }

        if (state.mode === 'style-comment') {
          let endIndex = text.indexOf('*/', index);
          if (endIndex === -1) {
            htmlParts.push(wrapToken('token-comment', text.slice(index)));
            index = length;
            break;
          }
          htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
          index = endIndex + 2;
          state.mode = 'style';
          continue;
        }

        if (state.mode === 'style') {
          if (index >= length) {
            break;
          }

          let ch = text.charAt(index);
          if (ch === '<' && startsWithIgnoreCase(text, index, '</style')) {
            state.mode = 'html-data';
            state.tagName = '';
            state.tagClosing = true;
            state.nextMode = '';
            continue;
          }

          if (ch === '/' && text.charAt(index + 1) === '*') {
            let endIndex = text.indexOf('*/', index + 2);
            if (endIndex === -1) {
              htmlParts.push(wrapToken('token-comment', text.slice(index)));
              state.mode = 'style-comment';
              index = length;
              break;
            }
            htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
            index = endIndex + 2;
            continue;
          }

          if (ch === '"' || ch === '\'') {
            let stringInfo = readStringLiteral(text, index, ch);
            htmlParts.push(wrapToken('token-string', stringInfo.value));
            index = stringInfo.end;
            if (!stringInfo.closed) {
              state.mode = 'style-string';
              state.delimiter = ch;
              break;
            }
            continue;
          }

          let whitespace = matchAt(WHITESPACE_RE, text, index);
          if (whitespace) {
            htmlParts.push(escapeHtml(whitespace));
            index += whitespace.length;
            continue;
          }

          if (ch === '#') {
            let color = matchAt(CSS_COLOR_RE, text, index);
            if (color) {
              htmlParts.push(wrapToken('token-css-color', color));
              index += color.length;
              continue;
            }
          }

          if (ch === '@') {
            let ident = matchAt(CSS_IDENTIFIER_RE, text, index + 1);
            let token = ident ? '@' + ident : '@';
            htmlParts.push(wrapToken('token-css-keyword', token));
            index += token.length;
            continue;
          }

          let numberValue = matchAt(CSS_NUMBER_RE, text, index);
          if (numberValue) {
            htmlParts.push(wrapToken('token-css-number', numberValue));
            index += numberValue.length;
            continue;
          }

          let ident = matchAt(CSS_IDENTIFIER_RE, text, index);
          if (ident) {
            let lower = ident.toLowerCase();
            if (CSS_KEYWORDS.has(lower)) {
              htmlParts.push(wrapToken('token-css-keyword', ident));
            } else {
              htmlParts.push(wrapToken('token-css-ident', ident));
            }
            index += ident.length;
            continue;
          }

          if (ch === '&') {
            let entityInfo = consumeEntity(text, index);
            htmlParts.push(wrapToken('token-entity', entityInfo.entity));
            index = entityInfo.end;
            continue;
          }

          let punct = matchAt(PUNCT_RE, text, index);
          if (punct) {
            htmlParts.push(wrapToken('token-punct', punct));
            index += punct.length;
            continue;
          }

          htmlParts.push(escapeHtml(ch));
          index += 1;
          continue;
        }

        state.mode = 'html-data';
      }

      return {
        html: htmlParts.join(''),
        state: createState(state.mode, {
          delimiter: state.delimiter,
          tagName: state.tagName,
          attrQuote: state.attrQuote,
          nextMode: state.nextMode,
          expectExpr: state.expectExpr,
          lastType: state.lastType,
          tagClosing: state.tagClosing
        })
      };
    }

    function ensureLineElements(doc, count) {
      while (doc.lineElements.length < count) {
        let span = document.createElement('span');
        span.className = 'line';
        span.innerHTML = '\u200B';
        doc.lineElements.push(span);
        doc.overlayPre.appendChild(span);
      }
      while (doc.lineElements.length > count) {
        let node = doc.lineElements.pop();
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
    }

    function adjustLineHtml(doc, size) {
      if (doc.lineHtml.length > size) {
        doc.lineHtml.length = size;
      }
      while (doc.lineHtml.length < size) {
        doc.lineHtml.push('');
      }
    }

    function adjustStates(doc, size) {
      if (doc.lineStates.length > size) {
        doc.lineStates.length = size;
      }
      while (doc.lineStates.length < size) {
        doc.lineStates.push(createState('html-data'));
      }
      doc.lineStates[0] = createState(doc.initialMode, {
        expectExpr: doc.initialMode === 'script',
        lastType: 'operator'
      });
    }

    function scheduleWork(doc) {
      if (doc.scheduled) {
        return;
      }
      if (doc.nextProcessLine >= doc.targetLine) {
        return;
      }
      doc.scheduled = true;
      requestNextChunk(doc);
    }

    function requestNextChunk(doc) {
      cancelPending(doc);
      if (typeof window.requestIdleCallback === 'function') {
        doc.pendingType = 'idle';
        doc.pendingHandle = window.requestIdleCallback(function (deadline) {
          runChunk(doc, deadline);
        }, { timeout: 100 });
      } else {
        doc.pendingType = 'raf';
        doc.pendingHandle = window.requestAnimationFrame(function () {
          runChunk(doc, {
            didTimeout: true,
            timeRemaining: function () {
              return 0;
            }
          });
        });
      }
    }

    function cancelPending(doc) {
      if (doc.pendingHandle === null) {
        return;
      }
      if (doc.pendingType === 'idle' && typeof window.cancelIdleCallback === 'function') {
        window.cancelIdleCallback(doc.pendingHandle);
      }
      if (doc.pendingType === 'raf') {
        window.cancelAnimationFrame(doc.pendingHandle);
      }
      doc.pendingHandle = null;
      doc.pendingType = '';
    }

    function runChunk(doc, deadline) {
      doc.scheduled = false;
      doc.pendingHandle = null;
      doc.pendingType = '';

      ensureLineElements(doc, doc.lines.length);
      adjustStates(doc, doc.lines.length + 1);

      if (doc.nextProcessLine < 0) {
        doc.nextProcessLine = 0;
      }

      let maxLinesPerChunk = 220;
      let processed = 0;
      let startTime = performance.now();

      while (doc.nextProcessLine < doc.lines.length) {
        if (doc.nextProcessLine >= doc.targetLine) {
          break;
        }
        if (deadline && !deadline.didTimeout && typeof deadline.timeRemaining === 'function' && deadline.timeRemaining() <= 0) {
          break;
        }
        if (!deadline && performance.now() - startTime > 14) {
          break;
        }

        let index = doc.nextProcessLine;
        let priorState = doc.lineStates[index];
        if (!priorState) {
          priorState = createState('html-data');
          doc.lineStates[index] = priorState;
        }

        let result = tokenizeLine(doc.lines[index], priorState);
        let htmlChanged = doc.lineHtml[index] !== result.html;
        if (htmlChanged) {
          doc.lineHtml[index] = result.html;
          let element = doc.lineElements[index];
          if (element) {
            element.innerHTML = result.html && result.html.length ? result.html : '\u200B';
          }
        }

        let stateChanged = !sameState(doc.lineStates[index + 1], result.state);
        if (stateChanged) {
          doc.lineStates[index + 1] = result.state;
        }

        doc.nextProcessLine += 1;
        processed += 1;

        if (htmlChanged || stateChanged) {
          doc.targetLine = Math.max(doc.targetLine, doc.nextProcessLine + 1);
        }

        if (doc.nextProcessLine >= doc.targetLine && !htmlChanged && !stateChanged) {
          break;
        }

        if (processed >= maxLinesPerChunk) {
          break;
        }
      }

      if (doc.nextProcessLine < doc.targetLine && doc.nextProcessLine < doc.lines.length) {
        scheduleWork(doc);
      } else {
        doc.nextProcessLine = Math.min(doc.nextProcessLine, doc.lines.length);
        doc.targetLine = doc.nextProcessLine;
      }
    }

    function applyText(doc, value) {
      let normalized = normalizeText(value);
      let nextLines = normalized.split('\n');
      let oldLines = doc.lines;
      let newInitialMode = detectInitialMode(normalized);
      let initialChanged = newInitialMode !== doc.initialMode;

      if (initialChanged) {
        doc.initialMode = newInitialMode;
        oldLines = [];
      }

      doc.lines = nextLines;
      adjustLineHtml(doc, nextLines.length);
      ensureLineElements(doc, nextLines.length);
      adjustStates(doc, nextLines.length + 1);

      let start = 0;
      let minLength = Math.min(oldLines.length, nextLines.length);
      while (start < minLength && oldLines[start] === nextLines[start]) {
        start += 1;
      }

      if (!initialChanged && start === oldLines.length && start === nextLines.length) {
        return;
      }

      let oldTail = oldLines.length;
      let newTail = nextLines.length;
      while (!initialChanged && oldTail > start && newTail > start && oldLines[oldTail - 1] === nextLines[newTail - 1]) {
        oldTail -= 1;
        newTail -= 1;
      }

      let dirtyStart = initialChanged ? 0 : Math.max(0, start - 1);
      let dirtyEnd = initialChanged ? nextLines.length : Math.min(nextLines.length, newTail + 1);

      if (doc.nextProcessLine > dirtyStart) {
        doc.nextProcessLine = dirtyStart;
      }
      doc.targetLine = Math.max(doc.targetLine, dirtyEnd);
      scheduleWork(doc);
    }


    function syncScroll(doc) {
      let top = doc.textarea.scrollTop;
      let left = doc.textarea.scrollLeft;
      doc.overlayPre.style.transform = 'translate(' + (-left) + 'px, ' + (-top) + 'px)';
    }

    function syncMetrics(doc) {
      let styles = window.getComputedStyle(doc.textarea);
      doc.overlayPre.style.fontFamily = styles.fontFamily;
      doc.overlayPre.style.fontSize = styles.fontSize;
      doc.overlayPre.style.lineHeight = styles.lineHeight;
      doc.overlayPre.style.letterSpacing = styles.letterSpacing;
      doc.overlayPre.style.wordSpacing = styles.wordSpacing;
      doc.overlayPre.style.paddingTop = styles.paddingTop;
      doc.overlayPre.style.paddingRight = styles.paddingRight;
      doc.overlayPre.style.paddingBottom = styles.paddingBottom;
      doc.overlayPre.style.paddingLeft = styles.paddingLeft;
      doc.overlayPre.style.tabSize = styles.tabSize;
      doc.overlayPre.style.boxSizing = 'border-box';
      doc.overlayHost.style.borderRadius = styles.borderRadius;
    }

    function lighted(textarea, options) {
      if (!(textarea instanceof HTMLTextAreaElement)) {
        throw new Error('lighted() expects a textarea element');
      }

      let parent = textarea.parentNode;
      if (!parent) {
        throw new Error('Textarea must be attached to the DOM before calling lighted()');
      }

      let config = options && typeof options === 'object' ? options : {};
      let tabSize = typeof config.tabSize === 'number' && config.tabSize > 0 ? Math.floor(config.tabSize) : 2;
      if (!isFinite(tabSize) || tabSize < 1) {
        tabSize = 2;
      }
      let defaultTabString = typeof ''.repeat === 'function' ? ' '.repeat(tabSize) : Array(tabSize + 1).join(' ');
      let tabString = typeof config.tabString === 'string' && config.tabString.length ? config.tabString : defaultTabString;
      if (!tabString.length) {
        tabString = '  ';
      }
      let convertTabsToSpaces = config.convertTabsToSpaces !== undefined ? !!config.convertTabsToSpaces : true;
      let autoIndent = config.autoIndent !== undefined ? !!config.autoIndent : true;

      let container = document.createElement('div');
      container.className = 'lighted';
      let overlayHost = document.createElement('div');
      overlayHost.className = 'overlay-host';
      overlayHost.setAttribute('aria-hidden', 'true');

      let shadow = overlayHost.attachShadow({ mode: 'open' });
      let shadowStyle = document.createElement('style');
      shadowStyle.textContent = [
        ':host {',
        '  display: block;',
        '  width: 100%;',
        '  height: 100%;',
        '  color: var(--lighted-foreground);',
        '  font: inherit;',
        '}',
        '.surface {',
        '  position: absolute;',
        '  inset: 0;',
        '  margin: 0;',
        '  font: inherit;',
        '  line-height: inherit;',
        '  white-space: pre;',
        '  color: inherit;',
        '  background: transparent;',
        '  pointer-events: none;',
        '  tab-size: inherit;',
        '  letter-spacing: inherit;',
        '  word-spacing: inherit;',
        '  box-sizing: border-box;',
        '  will-change: transform;',
        '}',
        '.surface span.line {',
        '  display: block;',
        '  white-space: pre;',
        '}',
        '.token-comment { color: var(--token-comment); }',
        '.token-string { color: var(--token-string); }',
        '.token-number { color: var(--token-number); }',
        '.token-keyword { color: var(--token-keyword); }',
        '.token-builtin { color: var(--token-builtin); }',
        '.token-punct { color: var(--token-punct); }',
        '.token-tag { color: var(--token-tag); }',
        '.token-attr { color: var(--token-attr); }',
        '.token-attr-value { color: var(--token-attr-value); }',
        '.token-entity { color: var(--token-entity); }',
        '.token-css-ident { color: var(--token-css-ident); }',
        '.token-css-keyword { color: var(--token-css-keyword); }',
        '.token-css-number { color: var(--token-css-number); }',
        '.token-css-color { color: var(--token-css-color); }',
        '.token-regex { color: var(--token-regex); }'
      ].join('\n');

      let overlayPre = document.createElement('pre');
      overlayPre.className = 'surface';
      overlayPre.setAttribute('aria-hidden', 'true');

      shadow.appendChild(shadowStyle);
      shadow.appendChild(overlayPre);

      parent.replaceChild(container, textarea);
      container.appendChild(overlayHost);
      container.appendChild(textarea);

      textarea.classList.add('lighted-input');
      textarea.style.backgroundColor = 'transparent';
      textarea.style.color = 'transparent';
      textarea.style.caretColor = 'var(--lighted-caret)';
      textarea.style.position = 'relative';
      textarea.style.zIndex = '1';
      textarea.style.whiteSpace = 'pre';
      textarea.setAttribute('wrap', 'off');

      let initialMode = detectInitialMode(textarea.value);

      let doc = {
        textarea: textarea,
        container: container,
        overlayHost: overlayHost,
        overlayPre: overlayPre,
        lines: [],
        lineHtml: [],
        lineStates: [createState(initialMode, { expectExpr: initialMode === 'script', lastType: 'operator' })],
        lineElements: [],
        nextProcessLine: 0,
        targetLine: 0,
        scheduled: false,
        pendingHandle: null,
        pendingType: '',
        initialMode: initialMode,
        tabString: tabString,
        convertTabsToSpaces: convertTabsToSpaces,
        autoIndent: autoIndent,
        config: config
      };

      syncMetrics(doc);
      if (typeof ResizeObserver === 'function') {
        let observer = new ResizeObserver(function () {
          syncMetrics(doc);
        });
        observer.observe(textarea);
        doc.resizeObserver = observer;
      }

      let handleKeyDown = function (event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey) {
          if (!doc.convertTabsToSpaces) {
            return;
          }
          event.preventDefault();
          if (event.shiftKey) {
            unindentSelection(doc, doc.tabString);
          } else {
            indentSelection(doc, doc.tabString);
          }
          handleInput();
          return;
        }
        if (event.key === 'Enter' && !event.altKey && !event.ctrlKey && !event.metaKey) {
          if (!doc.autoIndent) {
            return;
          }
          event.preventDefault();
          let value = textarea.value;
          let caret = textarea.selectionStart;
          let indent = getLineIndentation(value, caret, doc.tabString);
          let insertion = '\n' + indent;
          insertTextAtSelection(doc, insertion);
          handleInput();
        }
      };

      let handleInput = function () {
        applyText(doc, textarea.value);
      };

      textarea.addEventListener('keydown', handleKeyDown);
      textarea.addEventListener('input', handleInput);
      textarea.addEventListener('scroll', function () {
        syncScroll(doc);
      });

      applyText(doc, textarea.value);
      doc.targetLine = doc.lines.length;
      doc.nextProcessLine = 0;
      scheduleWork(doc);
      syncScroll(doc);

      return container;
    }

    let textarea = document.querySelector('#editor');
    new Vim(textarea, document.createElement('div'), document.createElement('div'), document.createElement('div'));
    let editorRoot = lighted(textarea);
    console.log('Lighted editor ready', editorRoot);
  </script>

</body>
</html>
