<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Lighted Syntax Highlighted Textarea</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      color-scheme: dark;
      --lighted-foreground: #d4d4d4;
      --lighted-background: #0f1219;
      --lighted-caret: #ffe66d;
      --token-comment: #6a9955;
      --token-string: #ce9178;
      --token-number: #b5cea8;
      --token-keyword: #c586c0;
      --token-builtin: #4fc1ff;
      --token-punct: #dcdcdc;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, rgba(52, 84, 209, 0.18), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(220, 92, 255, 0.2), transparent 40%),
        var(--lighted-background);
      color: var(--lighted-foreground);
      font-family: "Fira Code", "SFMono-Regular", Menlo, Monaco, "Courier New", monospace;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 36px 28px 64px;
    }

    main {
      width: min(960px, 100%);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 1.35rem;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    p {
      margin: 0 0 28px;
      max-width: 68ch;
      line-height: 1.6;
      color: rgba(212, 212, 212, 0.82);
    }

    .lighted {
      position: relative;
      width: 100%;
      border-radius: 12px;
      background: rgba(6, 8, 12, 0.75);
      box-shadow: 0 38px 80px rgba(0, 0, 0, 0.45);
      overflow: hidden;
    }

    .lighted-input {
      width: 100%;
      min-height: 420px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 22px 24px;
      font-size: 15px;
      line-height: 1.6;
      background: transparent;
      color: transparent;
      caret-color: var(--lighted-caret);
      resize: vertical;
      outline: none;
      position: relative;
      z-index: 1;
      white-space: pre;
      tab-size: 2;
      overflow: auto;
    }

    .lighted-input:focus {
      border-color: rgba(86, 156, 214, 0.6);
      box-shadow: 0 0 0 1px rgba(86, 156, 214, 0.4);
    }

    .lighted-input::selection {
      background: rgba(86, 156, 214, 0.32);
    }

    .lighted .overlay-host {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      border-radius: inherit;
    }
  </style>
</head>
<body>
  <main>
    <h1>Lightweight RegExp Syntax Highlighting Demo</h1>
    <p>
      The editor below keeps the original textarea for input, adds a shadow-DOM backed overlay that renders tokens,
      and incrementally retokens only the areas affected by edits.
    </p>
    <textarea id="editor" spellcheck="false">let message = 'Hello, Webfoundry!';

function greet(name) {
  /* highlight demonstration */
  let text = `${message} Welcome, ${name}!`;
  if (name === 'Camila') {
    console.log('Special handling for', name);
  }
  return text;
}

let items = [];
for (let i = 0; i < 6; i += 1) {
  items.push({ id: i, ready: i % 2 === 0 });
}

items.forEach(function (entry) {
  if (entry.ready) {
    console.log('Ready item', entry.id);
  }
});

export { greet };
</textarea>
  </main>
  <script type="module">
    let KEYWORDS = new Set([
      'break', 'case', 'catch', 'class', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export',
      'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'let', 'new', 'return', 'super',
      'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'await', 'static', 'of'
    ]);

    let BUILTINS = new Set([
      'Array', 'Boolean', 'Date', 'Error', 'Function', 'JSON', 'Math', 'Number', 'Object', 'Promise', 'RegExp',
      'String', 'Symbol', 'Map', 'Set', 'WeakMap', 'WeakSet', 'console', 'document', 'window', 'Intl'
    ]);

    let WHITESPACE_RE = /\s+/y;
    let NUMBER_RE = /(?:0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)/y;
    let IDENT_RE = /[A-Za-z_$][\w$]*/y;
    let PUNCT_RE = /==|===|!=|!==|=>|<=|>=|\+\+|--|\+=|-=|\*=|\/=|&&|\|\||[%+\-*/&|^~<>!?:=.,;()[\]{}]/y;

    let HTML_ESCAPES = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };

    function normalizeText(value) {
      return value.replace(/\r\n/g, '\n');
    }

    function matchAt(regex, text, index) {
      regex.lastIndex = index;
      let match = regex.exec(text);
      if (match && match.index === index) {
        return match[0];
      }
      return '';
    }

    function escapeHtml(text) {
      if (!text) {
        return '';
      }
      return text.replace(/[&<>"']/g, function (ch) {
        return HTML_ESCAPES[ch] || ch;
      });
    }

    function wrapToken(className, text) {
      return '<span class="' + className + '">' + escapeHtml(text) + '</span>';
    }

    function createState(mode, delimiter) {
      return {
        mode: mode || 'base',
        delimiter: delimiter || ''
      };
    }

    function sameState(a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return a.mode === b.mode && a.delimiter === b.delimiter;
    }

    function tokenizeLine(text, state) {
      let mode = state && state.mode ? state.mode : 'base';
      let delimiter = state && state.delimiter ? state.delimiter : '';
      let htmlParts = [];
      let index = 0;
      let length = text.length;

      while (index < length) {
        if (mode === 'block-comment') {
          let endIndex = text.indexOf('*/', index);
          if (endIndex === -1) {
            htmlParts.push(wrapToken('token-comment', text.slice(index)));
            index = length;
            break;
          } else {
            htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
            index = endIndex + 2;
            mode = 'base';
            delimiter = '';
            continue;
          }
        }

        if (mode === 'string') {
          let stopIndex = index;
          let closed = false;
          while (stopIndex < length) {
            let ch = text.charAt(stopIndex);
            if (ch === '\\') {
              stopIndex += 2;
              continue;
            }
            if (ch === delimiter) {
              stopIndex += 1;
              closed = true;
              break;
            }
            stopIndex += 1;
          }
          let chunk = text.slice(index, stopIndex);
          htmlParts.push(wrapToken('token-string', chunk));
          index = stopIndex;
          if (closed) {
            mode = 'base';
            delimiter = '';
          } else {
            index = length;
          }
          continue;
        }

        let ch = text.charAt(index);

        if (ch === '/' && index + 1 < length) {
          let next = text.charAt(index + 1);
          if (next === '/') {
            htmlParts.push(wrapToken('token-comment', text.slice(index)));
            index = length;
            break;
          }
          if (next === '*') {
            let endIndex = text.indexOf('*/', index + 2);
            if (endIndex === -1) {
              htmlParts.push(wrapToken('token-comment', text.slice(index)));
              mode = 'block-comment';
              delimiter = '';
              index = length;
              break;
            } else {
              htmlParts.push(wrapToken('token-comment', text.slice(index, endIndex + 2)));
              index = endIndex + 2;
              continue;
            }
          }
        }

        if (ch === '"' || ch === '\'' || ch === '`') {
          let stopIndex = index + 1;
          let closed = false;
          while (stopIndex < length) {
            let inner = text.charAt(stopIndex);
            if (inner === '\\') {
              stopIndex += 2;
              continue;
            }
            if (inner === ch) {
              stopIndex += 1;
              closed = true;
              break;
            }
            stopIndex += 1;
          }
          let chunk = text.slice(index, stopIndex);
          htmlParts.push(wrapToken('token-string', chunk));
          index = stopIndex;
          if (!closed) {
            mode = 'string';
            delimiter = ch;
            index = length;
          }
          continue;
        }

        let whitespace = matchAt(WHITESPACE_RE, text, index);
        if (whitespace) {
          htmlParts.push(escapeHtml(whitespace));
          index += whitespace.length;
          continue;
        }

        let numberValue = matchAt(NUMBER_RE, text, index);
        if (numberValue) {
          htmlParts.push(wrapToken('token-number', numberValue));
          index += numberValue.length;
          continue;
        }

        let ident = matchAt(IDENT_RE, text, index);
        if (ident) {
          if (KEYWORDS.has(ident)) {
            htmlParts.push(wrapToken('token-keyword', ident));
          } else if (BUILTINS.has(ident)) {
            htmlParts.push(wrapToken('token-builtin', ident));
          } else {
            htmlParts.push(escapeHtml(ident));
          }
          index += ident.length;
          continue;
        }

        let punct = matchAt(PUNCT_RE, text, index);
        if (punct) {
          htmlParts.push(wrapToken('token-punct', punct));
          index += punct.length;
          continue;
        }

        htmlParts.push(escapeHtml(ch));
        index += 1;
      }

      return {
        html: htmlParts.join(''),
        state: createState(mode, delimiter)
      };
    }

    function ensureLineElements(doc, count) {
      while (doc.lineElements.length < count) {
        let span = document.createElement('span');
        span.className = 'line';
        span.innerHTML = '\u200B';
        doc.lineElements.push(span);
        doc.overlayPre.appendChild(span);
      }
      while (doc.lineElements.length > count) {
        let node = doc.lineElements.pop();
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
    }

    function adjustLineHtml(doc, size) {
      if (doc.lineHtml.length > size) {
        doc.lineHtml.length = size;
      }
      while (doc.lineHtml.length < size) {
        doc.lineHtml.push('');
      }
    }

    function adjustStates(doc, size) {
      if (doc.lineStates.length > size) {
        doc.lineStates.length = size;
      }
      while (doc.lineStates.length < size) {
        doc.lineStates.push(createState('base'));
      }
      doc.lineStates[0] = createState('base');
    }

    function scheduleWork(doc) {
      if (doc.scheduled) {
        return;
      }
      if (doc.nextProcessLine >= doc.targetLine) {
        return;
      }
      doc.scheduled = true;
      requestNextChunk(doc);
    }

    function requestNextChunk(doc) {
      cancelPending(doc);
      if (typeof window.requestIdleCallback === 'function') {
        doc.pendingType = 'idle';
        doc.pendingHandle = window.requestIdleCallback(function (deadline) {
          runChunk(doc, deadline);
        }, { timeout: 100 });
      } else {
        doc.pendingType = 'raf';
        doc.pendingHandle = window.requestAnimationFrame(function () {
          runChunk(doc, {
            didTimeout: true,
            timeRemaining: function () {
              return 0;
            }
          });
        });
      }
    }

    function cancelPending(doc) {
      if (doc.pendingHandle === null) {
        return;
      }
      if (doc.pendingType === 'idle' && typeof window.cancelIdleCallback === 'function') {
        window.cancelIdleCallback(doc.pendingHandle);
      }
      if (doc.pendingType === 'raf') {
        window.cancelAnimationFrame(doc.pendingHandle);
      }
      doc.pendingHandle = null;
      doc.pendingType = '';
    }

    function runChunk(doc, deadline) {
      doc.scheduled = false;
      doc.pendingHandle = null;
      doc.pendingType = '';

      ensureLineElements(doc, doc.lines.length);
      adjustStates(doc, doc.lines.length + 1);

      if (doc.nextProcessLine < 0) {
        doc.nextProcessLine = 0;
      }

      let maxLinesPerChunk = 220;
      let processed = 0;
      let startTime = performance.now();

      while (doc.nextProcessLine < doc.lines.length) {
        if (doc.nextProcessLine >= doc.targetLine) {
          break;
        }
        if (deadline && !deadline.didTimeout && typeof deadline.timeRemaining === 'function' && deadline.timeRemaining() <= 0) {
          break;
        }
        if (!deadline && performance.now() - startTime > 14) {
          break;
        }

        let index = doc.nextProcessLine;
        let priorState = doc.lineStates[index];
        if (!priorState) {
          priorState = createState('base');
          doc.lineStates[index] = priorState;
        }

        let result = tokenizeLine(doc.lines[index], priorState);
        let htmlChanged = doc.lineHtml[index] !== result.html;
        if (htmlChanged) {
          doc.lineHtml[index] = result.html;
          let element = doc.lineElements[index];
          if (element) {
            element.innerHTML = result.html && result.html.length ? result.html : '\u200B';
          }
        }

        let stateChanged = !sameState(doc.lineStates[index + 1], result.state);
        if (stateChanged) {
          doc.lineStates[index + 1] = result.state;
        }

        doc.nextProcessLine += 1;
        processed += 1;

        if (htmlChanged || stateChanged) {
          doc.targetLine = Math.max(doc.targetLine, doc.nextProcessLine + 1);
        }

        if (doc.nextProcessLine >= doc.targetLine && !htmlChanged && !stateChanged) {
          break;
        }

        if (processed >= maxLinesPerChunk) {
          break;
        }
      }

      if (doc.nextProcessLine < doc.targetLine && doc.nextProcessLine < doc.lines.length) {
        scheduleWork(doc);
      } else {
        doc.nextProcessLine = Math.min(doc.nextProcessLine, doc.lines.length);
        doc.targetLine = doc.nextProcessLine;
      }
    }

    function applyText(doc, value) {
      let normalized = normalizeText(value);
      let nextLines = normalized.split('\n');
      let oldLines = doc.lines;

      doc.lines = nextLines;
      adjustLineHtml(doc, nextLines.length);
      ensureLineElements(doc, nextLines.length);
      adjustStates(doc, nextLines.length + 1);

      let start = 0;
      let minLength = Math.min(oldLines.length, nextLines.length);
      while (start < minLength && oldLines[start] === nextLines[start]) {
        start += 1;
      }

      if (start === oldLines.length && start === nextLines.length) {
        return;
      }

      let oldTail = oldLines.length;
      let newTail = nextLines.length;
      while (oldTail > start && newTail > start && oldLines[oldTail - 1] === nextLines[newTail - 1]) {
        oldTail -= 1;
        newTail -= 1;
      }

      let dirtyStart = Math.max(0, start - 1);
      let dirtyEnd = Math.min(nextLines.length, newTail + 1);

      if (doc.nextProcessLine > dirtyStart) {
        doc.nextProcessLine = dirtyStart;
      }
      doc.targetLine = Math.max(doc.targetLine, dirtyEnd);
      scheduleWork(doc);
    }

    function syncScroll(doc) {
      let top = doc.textarea.scrollTop;
      let left = doc.textarea.scrollLeft;
      doc.overlayPre.style.transform = 'translate(' + (-left) + 'px, ' + (-top) + 'px)';
    }

    function syncMetrics(doc) {
      let styles = window.getComputedStyle(doc.textarea);
      doc.overlayPre.style.fontFamily = styles.fontFamily;
      doc.overlayPre.style.fontSize = styles.fontSize;
      doc.overlayPre.style.lineHeight = styles.lineHeight;
      doc.overlayPre.style.letterSpacing = styles.letterSpacing;
      doc.overlayPre.style.wordSpacing = styles.wordSpacing;
      doc.overlayPre.style.paddingTop = styles.paddingTop;
      doc.overlayPre.style.paddingRight = styles.paddingRight;
      doc.overlayPre.style.paddingBottom = styles.paddingBottom;
      doc.overlayPre.style.paddingLeft = styles.paddingLeft;
      doc.overlayPre.style.tabSize = styles.tabSize;
      doc.overlayPre.style.boxSizing = 'border-box';
      doc.overlayHost.style.borderRadius = styles.borderRadius;
    }

    function lighted(textarea) {
      if (!(textarea instanceof HTMLTextAreaElement)) {
        throw new Error('lighted() expects a textarea element');
      }

      let parent = textarea.parentNode;
      if (!parent) {
        throw new Error('Textarea must be attached to the DOM before calling lighted()');
      }

      let container = document.createElement('div');
      container.className = 'lighted';
      let overlayHost = document.createElement('div');
      overlayHost.className = 'overlay-host';
      overlayHost.setAttribute('aria-hidden', 'true');

      let shadow = overlayHost.attachShadow({ mode: 'open' });
      let shadowStyle = document.createElement('style');
      shadowStyle.textContent = [
        ':host {',
        '  display: block;',
        '  width: 100%;',
        '  height: 100%;',
        '  color: var(--lighted-foreground);',
        '  font: inherit;',
        '}',
        '.surface {',
        '  position: absolute;',
        '  inset: 0;',
        '  margin: 0;',
        '  font: inherit;',
        '  line-height: inherit;',
        '  white-space: pre;',
        '  color: inherit;',
        '  background: transparent;',
        '  pointer-events: none;',
        '  tab-size: inherit;',
        '  letter-spacing: inherit;',
        '  word-spacing: inherit;',
        '  box-sizing: border-box;',
        '  will-change: transform;',
        '}',
        '.surface span.line {',
        '  display: block;',
        '  white-space: pre;',
        '}',
        '.token-comment { color: var(--token-comment); }',
        '.token-string { color: var(--token-string); }',
        '.token-number { color: var(--token-number); }',
        '.token-keyword { color: var(--token-keyword); }',
        '.token-builtin { color: var(--token-builtin); }',
        '.token-punct { color: var(--token-punct); }'
      ].join('\n');

      let overlayPre = document.createElement('pre');
      overlayPre.className = 'surface';
      overlayPre.setAttribute('aria-hidden', 'true');

      shadow.appendChild(shadowStyle);
      shadow.appendChild(overlayPre);

      parent.replaceChild(container, textarea);
      container.appendChild(overlayHost);
      container.appendChild(textarea);

      textarea.classList.add('lighted-input');
      textarea.style.backgroundColor = 'transparent';
      textarea.style.color = 'transparent';
      textarea.style.caretColor = 'var(--lighted-caret)';
      textarea.style.position = 'relative';
      textarea.style.zIndex = '1';
      textarea.style.whiteSpace = 'pre';
      textarea.setAttribute('wrap', 'off');

      let doc = {
        textarea: textarea,
        container: container,
        overlayHost: overlayHost,
        overlayPre: overlayPre,
        lines: [],
        lineHtml: [],
        lineStates: [createState('base')],
        lineElements: [],
        nextProcessLine: 0,
        targetLine: 0,
        scheduled: false,
        pendingHandle: null,
        pendingType: ''
      };

      syncMetrics(doc);
      if (typeof ResizeObserver === 'function') {
        let observer = new ResizeObserver(function () {
          syncMetrics(doc);
        });
        observer.observe(textarea);
        doc.resizeObserver = observer;
      }

      let handleInput = function () {
        applyText(doc, textarea.value);
      };

      textarea.addEventListener('input', handleInput);
      textarea.addEventListener('scroll', function () {
        syncScroll(doc);
      });

      applyText(doc, textarea.value);
      doc.targetLine = doc.lines.length;
      doc.nextProcessLine = 0;
      scheduleWork(doc);
      syncScroll(doc);

      return container;
    }

    let textarea = document.querySelector('#editor');
    let editorRoot = lighted(textarea);
    console.log('Lighted editor ready', editorRoot);
  </script>
</body>
</html>
